---
title: "Tutorial"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
knitr::opts_chunk$set(echo = FALSE)
#install.packages("schrute")
library(schrute)
#View(theoffice)
library(tidyverse)
library(dplyr)
library(ggthemes)
```

```{r, include = FALSE}
#converting season and episode to numeric
theoffice$season<-as.numeric(theoffice$season)
theoffice$episode<-as.numeric(theoffice$episode)
```
# Intoduction to Data Wrangling
Data wrangling is a process that takes data sets and transforms it into a form that is more helpful for the task you are trying to complete. Data can be changed or modified, renamed, and even removed. In R, there are many functions that can be used on a data set to complete the process of data wrangling. 

## The Data Set
In this tutorial, we will be using theoffice data set in the schrute package, which contains the season, episode number and name, characters and their lines (in order), among some other pieces of information regarding the show.

## Functions

**The select() function**
The select() function is used to choose which *columns* you would like the include. You can also use select to remove columns. The order in which you include the columns are the order they will appear in in your new data set. 

**The filter() function**
The filter() function is used to select which *rows* you would like to include. To select a single parameter, use an '=', to select multiple parameters, use an '%in%', along with a vector of the parameters( in the format c("","",...))

**The mutate() function**
The mutate function changes the data set. You can use this function to add new rows based on existing rows, or to modify existing rows.

**The arrange() function**
The arrange() function arranges *rows*. It defaults to arranging the data in ascending order, but can also be written to arrange in descending order, which is sometimes more helpful. You just select the column you would like to arrange by.

**The rename() function**
The rename() function does exactly that: renames *columns*(variables). 

**The summarize() function**
The summarize() function creates a data set based on a specific summary statistic. For example, if you wanted the mean of a particular value, the new data set would report the data based on the mean values found. This function is often used alongside group_by().

**The group_by() function**
The group_by() function groups the data. This *must* be used before another function, like summarize. When used together, you can group by a specific parameter and then calculate the summary statistics for each subgroup. 

**The top_n() function**
The top_n() function is used to report the top numbers for a specific variable or value. You can specify how many values you would like reported in the table within the function.

## Exercises

*step 1*: Create dataset for season 1
```{r example_code, exercise = TRUE}
season1 = theoffice %>%   #creates a new dataset season1 from theoffice dataset
  filter(season == 01) %>%   #select all ROWS pertaining to season 1 (01 in the season column)
  select(episode, episode_name, imdb_rating) %>%   #select the COLUMNS to include in the new dataset
  group_by(episode, episode_name) %>%   #group the dataset by episode and episode name
  summarize(imdb_rating = paste(unique(imdb_rating),
                                collapse = ", "))   #summarize by the groups specified in group_by(), and creates a new 
                                                    #imdb_rating column by collapsing the data into one row per episode
```

*step 2*: Practice!
Create a data set like the one above, but for season 2. Report a table including the following columns: season, episode, episode_name, and imdb_rating. Fill in the correct information in the *select* and *filter()* rows.
```{r practice1, exercise = TRUE}
season2 = theoffice %>% 
  select() %>%
  filter() %>% 
  group_by(episode, episode_name) %>% 
  summarize(imdb_rating = paste(unique(imdb_rating), collapse = ", "))
```

Run the following code to calculate the average rating for each season, along with the number of episodes in each season
```{r season_avg, exercise = TRUE}
seasons_avg = theoffice %>%   #creates a new dataset for the average rating per season
  select(season, episode, imdb_rating) %>%   #select the COLUMNS to use to create the new dataset
  group_by(season) %>%   #group the dataset by season
  mutate(avg_rating = mean(imdb_rating, na.rm = TRUE))%>%   #create a new COLUMN called avg_rating by calculating the 
                                                            #mean for each season
  group_by(season, episode, avg_rating) %>%   #group the dataset by season, episode and the new column avg_rating
  summarize(num_episodes = n()) %>%   #caluclates number of episodes per season 
                                      #**Note: inaccurate due to multiple rows per season in original dataset 
  group_by(season, avg_rating) %>%   #group by season and avg_rating again
  summarize(num_episodes = n()) %>%   #calculates the number of episodes per season in new COLUMN called num_episodes
  select(season, num_episodes, avg_rating)  #reorder selected columns
head(seasons_avg, 9)  #displays first 9 rows of dataset
```

Now, using what you've learned about the filter() function, create a data set with the average rating and number of episodes for seasons 3 and 8.
```{r season_avg_3_8, exercise = TRUE}
seasons_avg_3_8 = theoffice %>% 
  filter() %>% 
  select(season, episode, imdb_rating) %>% 
  group_by(season) %>% 
  mutate(avg_rating = mean(imdb_rating, na.rm = TRUE))%>% 
  group_by(season, episode, avg_rating) %>% 
  summarize(num_episodes = n()) %>% 
  group_by(season, avg_rating) %>% 
  summarize(num_episodes = n()) %>% 
  select(season, num_episodes, avg_rating)
head(seasons_avg_3_8, 2)
```

```{r}
ggplot(data = seasons_avg, aes(x = reorder(season, -season), y = avg_rating)) + 
  geom_col(fill = "lightgoldenrod2", color = "lightgoldenrod4") + 
  labs(title = "Average IMDb Rating Per Season", subtitle = "The Office (U.S.)", x = "", y = "Average Rating") + 
  theme_economist_white() + 
  theme(axis.text.y = element_blank(), axis.ticks.y = element_blank()) + 
  scale_y_continuous(breaks = seq(0,9, by = 1.0), labels = c(0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0)) + 
  coord_flip()
  #geom_text(aes(label = avg_rating, vjust = 0.5)
```

















